(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{288:function(t,a,s){"use strict";s.r(a);var r=s(14),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"js单线程和event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js单线程和event-loop"}},[t._v("#")]),t._v(" JS单线程和Event loop")]),t._v(" "),a("h3",{attrs:{id:"原因-避免dom渲染冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因-避免dom渲染冲突"}},[t._v("#")]),t._v(" 原因——避免DOM渲染冲突")]),t._v(" "),a("ul",[a("li",[t._v("浏览器需要渲染DOM")]),t._v(" "),a("li",[t._v("JS可以修改DOM结构")]),t._v(" "),a("li",[t._v("JS执行的时候，浏览器DOM会暂停")]),t._v(" "),a("li",[t._v("两段JS也不能同时执行(都修改DOM就冲突)")]),t._v(" "),a("li",[t._v("webworker支持多线程，但是不能访问DOM")])]),t._v(" "),a("h4",{attrs:{id:"解决方案-异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-异步"}},[t._v("#")]),t._v(" 解决方案——异步")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setTimeout // 时间到了再执行\najax // 加载完再执行\n")])])]),a("h3",{attrs:{id:"异步问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步问题"}},[t._v("#")]),t._v(" 异步问题")]),t._v(" "),a("ul",[a("li",[t._v("没按照书写方式执行，可读性差")]),t._v(" "),a("li",[t._v("callback中不容易模块化")])]),t._v(" "),a("h3",{attrs:{id:"实现异步的方案-event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现异步的方案-event-loop"}},[t._v("#")]),t._v(" 实现异步的方案——Event Loop")]),t._v(" "),a("ul",[a("li",[t._v("事件轮询，JS实现异步的具体解决方案")]),t._v(" "),a("li",[t._v("同步代码，直接执行")]),t._v(" "),a("li",[t._v("异步函数先放在异步队列中")]),t._v(" "),a("li",[t._v("待同步函数执行完毕，轮询执行异步队列的函数")])]),t._v(" "),a("h3",{attrs:{id:"异步任务中的分类-宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步任务中的分类-宏任务和微任务"}},[t._v("#")]),t._v(" 异步任务中的分类——宏任务和微任务")]),t._v(" "),a("h4",{attrs:{id:"宏任务-script、-settimeout、setinterval、ajax、requrestanimationframe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务-script、-settimeout、setinterval、ajax、requrestanimationframe"}},[t._v("#")]),t._v(" 宏任务: script、 setTimeout、setInterval、ajax、requrestAnimationFrame")]),t._v(" "),a("ol",[a("li",[t._v("宏任务所处的队列就是宏任务队列")]),t._v(" "),a("li",[t._v("第一个宏任务队列中只有一个任务：执行主线程的js代码")]),t._v(" "),a("li",[t._v("宏任务队列可以有多个")]),t._v(" "),a("li",[t._v("当宏任务队列中的任务全部执行完以后会查看是否有微任务队列，如果有，先执行微任务队列中的所有任务。如果没有就查看是否有宏任务队列。")])]),t._v(" "),a("h4",{attrs:{id:"微任务-promise-then-回调-、process-nexttick-node中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微任务-promise-then-回调-、process-nexttick-node中"}},[t._v("#")]),t._v(" 微任务: Promise().then(回调)、process.nextTick(node中)")]),t._v(" "),a("ol",[a("li",[t._v("微任务所处的队列就是微任务队列")]),t._v(" "),a("li",[t._v("只有一个微任务队列")]),t._v(" "),a("li",[t._v("在上一个宏任务队列执行完毕后如果有微任务队列就执行微任务队列中所有任务")])]),t._v(" "),a("h4",{attrs:{id:"总结-js是单线程-同时只做一件事-原因是为了避免dom渲染冲突。异步是一种解决方案-具体的实现就是event-loop。同步代码直接执行-异步代码先放在异步队列中-待同步代码完毕-轮询执行异步队列中函数。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结-js是单线程-同时只做一件事-原因是为了避免dom渲染冲突。异步是一种解决方案-具体的实现就是event-loop。同步代码直接执行-异步代码先放在异步队列中-待同步代码完毕-轮询执行异步队列中函数。"}},[t._v("#")]),t._v(" 总结：JS是单线程，同时只做一件事，原因是为了避免DOM渲染冲突。异步是一种解决方案，具体的实现就是Event Loop。同步代码直接执行，异步代码先放在异步队列中，待同步代码完毕，轮询执行异步队列中函数。")]),t._v(" "),a("h4",{attrs:{id:"异步任务又可以分为两种-micro-tast-微任务-和macro-tast-宏任务-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步任务又可以分为两种-micro-tast-微任务-和macro-tast-宏任务-。"}},[t._v("#")]),t._v(" 异步任务又可以分为两种，micro-tast(微任务)和macro-tast(宏任务)。")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("初始化状态：执行stack为空。macro-tast(宏任务)队列中只有一个script脚本。")])]),t._v(" "),a("li",[a("p",[t._v("script脚本被推入执行stack，同步代码执行，执行过程可以产生新的macro-task和micro-task，并且推入各自的队列中，script脚本执行完成，则会移除任务队列。")])]),t._v(" "),a("li",[a("p",[t._v("macro-task移除队列后，接着执行micro-task。")])]),t._v(" "),a("li",[a("p",[t._v("执行UI渲染操作，更新界面。")])]),t._v(" "),a("li",[a("p",[t._v("继续执行下一个宏任务")])])]),t._v(" "),a("h4",{attrs:{id:"注意-macro-task是一个个执行的-而micro-task是一队一对执行。因此-处理micro会逐个执行-直至队列被清空。每个macro-task之间会进行render"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意-macro-task是一个个执行的-而micro-task是一队一对执行。因此-处理micro会逐个执行-直至队列被清空。每个macro-task之间会进行render"}},[t._v("#")]),t._v(" 注意：macro-task是一个个执行的，而micro-task是一队一对执行。因此，处理micro会逐个执行，直至队列被清空。每个macro-task之间会进行render")])])}),[],!1,null,null,null);a.default=e.exports}}]);